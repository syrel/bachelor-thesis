! Structure of the editor

One of the requirements for the editor was an ability to embed visual components inside of a text such that they are not deletable nor selectable. We call those elements ==adornments==. In order to unify how text and adornments are being treated, the editor also represents pieces of text as visual elements, thus completely removing the gap between embedded graphical components and text which is what allows us to have a single composition tree.The basis and foundation of the editor is a text model. One of the intreseting aspects of that text model is the fact that it is data structure independent. It allows us to implement different types of text models, for example ==SubText==, that can scope existing text model within some character interval, or ==SpanText==, that represents a uniform piece of text with every character having the same attributes. From the text editor's perspective there is no difference between those types of text, the interraction happens through a clear ==Text== api. More about text model can be found in the "Text model" chapter.When talking about text model we should not forget about text style, which is defined by a set of text attributes. Those attributes can be applied on the text manually with the help of corresponding text model api or created automatically by text stylers. Text stylers play an important role in syntax highlighting used by code editor.  Even more important role they play in the moldable editor as they are used to add ==adornment== attributes and hence provide a nice way to plug-in custom behaviour in the editor. Text stylers take context into account which is essential for creation of context-aware developement tools. In order for the editor to be fast and responsive, long and time consuming operations such text parsing and styling should happen in a parallel backround thread. While being easy to explain it is in fact a non-trivial task, since users are able to perform text modification operations while styler applies attributes on that text being modified. In the "Text styler" chapter we will talk more about problems and diffuculties related to text styling and introduce a solution that is currently implemented in and used by the moldable text editor.In order for the moldable editor to be scalable, it should split text into logical segments and render only those ones that are currently visible. A segment can be a page, a paragraph or a line. In the current implementation, the text editor creates line segments with the help of a line segment builder. The process of splitting text into segments is trivial, however keeping segments in sync with the text model after modification such as insertions and deletions is a difficult part and very error-prone. A segments update procedure will be discussed in the "Segments" chapter.Once segments are built they should be rendered as visual elements and displayed within the editor. The way it happens is similar to how modern scrolling lists work, for example ==FastTable== in Pharo, ==RecyclerView== in Android or ==UITableView== in iOS. Segments are hold by a data source object which knows how segments should be represented. It is also responsible for binding a segment model to its visual representation. In most cases a logical segment consists of multiple segment pieces, for example a line segment consists of words - text pieces separated by a white space. White space itself is also a piece within a line segment. A structure of the visual part of the editor will be explained in more details in the "Rendering" chapter.The last but not least is a ==TextEditor== itself that provides high level text modification api and allows developers to specify shortcuts.