! Text ModelIn order to display and edit text, an editor requires a text model that provides text modification and enumeration api. In a context of text editor under ==Text== we understand an object that consists of a collection of characters with a set of attributes applied on those characters and a number of api methods to support text modifications such as ==insert:== or ==delete:==. Additionally,text should play a role of sequenceable and indexable collection, allowing uses to iterate over all characters in a natural ordered way. Being indexable is also an essential property of a text model, since text stylers require text to have characters accessible by index. It is a consequence of a fact that code parsers create an AST which consists of nodes bound to original text with the help of integer intervals that are later used by a text styler to apply attributes on a piece of text defined by that ineteger intervals in a form of a ==[from, to]== tuple.One of the main requirements for the moldable editor is an ability to manipulate large pieces of text that consist of millions of characters and sometimes even more. It means that choosing an appropriate data structure for storing text is crusial. While looking for a data structure that would fit the needs of the moldable editor we found out that there is no the best data structure that is the only choice. It turned out that depending on a context and the way a text editor will be used it may be important to be able to select one or another data structure. Not to mention is the fact that text data structure should be choosen during early development stages, before the editor becomes usable. That is why the text model of the moldable editor is data structure independent and only defines a public api. In order for it to be used by a text editor developers should create concrete implemenations of that api with the data structure of choise as a backend. In the following section we will look at different data structures being used by text editors and compare them.! Text data structuresReference:Charles Crowley. "Data Structures for Text Sequences"(http://www.cs.unm.edu/~crowley/papers/sds.pdf)!! PharoIn Pharo there already exist two text models based on different data structures: one is ==Text== which is used by both Morphic and Rubric text editors, and ==TxModel== used by TxText editor. In the following sections we will compare and evaluate those text models regarding various properties such as ability to store, access and modify large pieces of text or whether they allow developers to embed non-textual object within text.!!! ==Text== model of Morphic and Rubric text editors==Text== is a default Pharo text model. It stores a collection of characters and a set of attributes separately. Characters are represented with the help of ==ByteString== which is nothing else than an immutable array of characters. It means that every text modification such as insertion or deletion requires it to allocate and copy the whole characters array while replacing a subsequence of characters with a requested one. Thus, implementation of text modifications are linear time algorithms, which is unacceptably slow when text size grows over hundreds of thousands of characters. In fact, array is the worst data structure for text sequences. (page 21.  Charles Crowley. "Data Structures for Text Sequences").!!! ==TxModel== of the TxText editor==TxModel== is a central class representing a text in the TxText editor. Internally is stores character sequences as a double-linked list of spans that consists of an actual text content. A linked list is considered to be an extreme as opposed to an array method of storing text. While insertions and deletions in a linked list are fast and easy, it is only indexable in a linear time which makes styling one of the slowest among all other text data structures.  (page 9-10, p20-21.  Charles Crowley. "Data Structures for Text Sequences").!! AtomReference:The State of Atom's Performance, 10th January 2018(http://blog.atom.io/2018/01/10/the-state-of-atoms-performance.html)Atom text editor uses a memory-efficient data structure similar to a Piece Table. Piece table is a memory efficient data structure based of two buffers, one of which represents original read-only text while the second one stores all modifications done to that text. All essential operations are performed with an adequate performance and some of them can  be efficiently improved by using cache. Piece table is considered to be the data structure of choice for a text editor. (p 16. Charles Crowley. "Data Structures for Text Sequences")!! EmacsReference:Emacs - The Buffer Gap(https://www.gnu.org/software/emacs/manual/html_node/elisp/Buffer-Gap.html)TODO!! RopeReference:Boehm, Hans-J; Atkinson, Russ; Plass, Michael (December 1995). "Ropes: an Alternative to Strings" (PDF). Software—Practice & Experience. New York, NY, USA: John Wiley & Sons, Inc. 25 (12): 1315–1330. doi:10.1002/spe.4380251203.(http://citeseer.ist.psu.edu/viewdoc/download?doi=10.1.1.14.9450&rep=rep1&type=pdf)